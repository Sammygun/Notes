Олег Молчанов введение
https://www.youtube.com/watch?v=VXYyJX5qMiQ&list=PLlWXhlUMyooaeSj8L8tVVbtUo0WCO4ORR

codewars рекомендовал

sublime text 
 
https://sublimetext.ru/documentation/hotkeys/windows
1 alt + 1 и т.д. переключение между вкладками 
2 ctrl + f4	Закрыть вкладку.
3 ctrl + tab	Переключиться на следующую вкладку.
 

=================

vs code настройка
Урок 6 python extension и далее остановка на 8
 ctrl + ` ### вызов терминал в vscode также переключение между текстом и терминалом
 ctrk + b #боковая панель убрать поставить
 ctrl + tab ## переключение 
1 расширения =  python = install потом просто перезагрузи его

2 в правом нижнем углу vs code выберите интерпретатор
python 3.8 выбери 
справо появиться уведомление установите linter pylint позволяет видеть ошибки до запуска кода
ctrl + shift + m ### позволяет увидеть есть ли проблемы панель problems снизу view = problems

3 view = command palette =  ctrl + shift + p = lint = все команды lint (возможно надо выбрать on) = select linter = выбери pylint (самый популярный)

4 настройка шрифта = справо внизу шарнир = setings = text editor = font size 21 
настройки шрифта терминала = справо внизу шарнир = setings = features = terminal = font size 18 

5 русификация
плагин Russian Language Pack for Visual Studio Code установи его

6 настройка github
https://habr.com/ru/post/490754/#github

7 проблема с курсором исчезает при alt - shift смене языка просто меняю на ctrl + shift
==========================================
Важные пометки
1 name = 'World'
s = 'Hello {}'
result = s.format(name) ## метод форматирования переменной s в строку подставили переменную name!!!!!!!!!!!
print(result)
Hello World ### вывод значения

2 result = pattern.format(name, number) #### значение переменных просто без кавычек


3 result = pattern.format(movie=name, rating=number) ### присваиваю переменные старым значениям без пробелов!!!!!!!!! в методе

4 def greet(): ### создание функции
	print('Hello world') # правило написания функций обязательно tab или 4 отступа shift + tab вернуться обратно

greet() ## обрашение к функциии теперь могу обращаться к функции
Hello world ## вывод
====================================================================
Git
1 git init  ## в папке проекта 
Initialized empty Git repository in ~/djangogirls/.git/
2 git config --global user.name "Sammygun" ### пользователь
3 git config --global user.email sam.rybtsov@gmail.com ## почта
4 git status ## смотрю какие изменения были
5 git add --all .
6 git commit -m "basics python" ## закоммитил изменения дал название изменениям

7  github добавляю на сайте !!!!!!!!!
(setings там можно удалить или переименовать репозиторий)
1 add new my-first-blog ## на сайте github !!!!!! (галочки можеш не ставить)
none везде добавляй
2 выбирай https 
(…or push an existing repository from the command line)

8 У себя в теривнале 
 git remote add origin https://github.com/Sammygun/Basic_python.git
 git branch -M main
 git push -u origin main


9 ЕСЛИ СДЕЛАЛ УЖЕ ИЗМЕНЕНИЯ КАКИЕ НИТЬ на сайте то:
1 git status ## смотрю что поменялось
2 git add --all . ## находясь в папке djangogirls
3 git status ### тут увижу что именно будет загружаться
4 git commit -m "Changed the HTML for the site." ### коммитим с заметкой
5 git push ### пушим на gut hub

===============================================================================
курсы по python

1 Урок введение

1 создаю файл hello_world.py
2 внутри прописываю 
print('hello world')
3 python3 hello_world.py ### запуск скрипта в терминале без chmod +x 
4 python3 -i hello_world.py ### тоже самое только с вызовом интерпретатора
5 python3 # в терминале вызавит интерпретатор

=============================================
Урок 2 типы данных, объекты, литералы
1 python3 ## вызов интерпретатора
'1' + '1' ### строка
'11' ## вывод

2 1 + 1  ## числа
2 ### вывод 

3 1.1 # c плавающей точкой

4 type(1) ## определит тип int
  type('hello') ## тип str
также можно туда поставить переменную чтобы ее проверить  
====================================

Урок 3 Основы Python Строки
Создание строк обязательно кавычки
1 'hello'
2 "hello"
3 'hello"  будет ошибка 
4 'hello "world" man' ## так ошибки не будет
5 "hello \'world\' man" ## экранирование ковычек все будет норм
6 id('asdf') ## узнаю уникальный номер объекта
140319020637488
7 dir("hello_world") ## покажет все методы которые мы можем реализовать с данным объектом также с переменной
строковые и числовые объекты имеют разные атрибуты
8 1 'hello' + "world" ##коннектинация называется объединение строк
'helloworld' ## вывод

2 'hello' + ' ' + "world" ###c пробелом
'hello world' ## вывод

9 'A' * 10 ## умножение строк, умножить на 10 
'AAAAAAAAAA' ###

10 'hello' * 5
'hellohellohellohellohello' ### 5 слов hello

11 len("hello world") ## узнаю длинну строки 
	11 ### вывод пробелы тоже считаются
12 len('') # без пробела вывод 0
   len(' ') ## вывод 1 один пробел есть

13 Хочу посмотреть какой метод могу использовать для строки
1 dir('') ## тут вижу куча методов основные всего 5 штук
2 'hello world'.upper()
'HELLO WORLD' ## вывод

3 'hello world'.title()
'Hello World' ### просто первые буквы с большой 

4  метод strip от слова стриптиз раздевать
'hello            '.strip() ### удаляет лишние пробелы
'hello' ## вывод

5 '        hello;;;;;'.strip(';') ### в такой последовательность удалит ; помни про запятые в скобках
'        hello' ### вывод прообелы останутся


Урок 4 Основы Python #3: числа
1 type(1)
<class 'int'> # int число

2 type(1.3)
<class 'float'> ## foat число с плавающей точкой

3 dir(1) ## увижу все методы для чисел

4  Простые операции с числами в интерпретаторе
1 1 + 1
  2
2 ()+ - **(это возведение в степень)

3  10/3
3.3333333333333335

4 round(10/3)
3 ## вывод округлит сделает целое число

5 round(10/3, 4)
3.3333 ## округлит до 4 цифр после запятой

6 10 % 3 ### деление по модулю
1 ## 10 - 9 = 1 при делении на кратному трем(9) будет остаток 1 

7 10 // 3
3 ## целочисленное деление без остатка

8 27 // 5 
5 ### 5*5 = 25 показывает число без остатка

9 float(1) ## вызваю функцию float создаю из число число с плавающей точкой
1.0

10 int(1.0) ## и наоборот вызываю функцию int создаю число обычное из числа с плавающей точкой
1

11  int(5.9)
5 #### удобно убирает не нужный остаток

12 str(1)
'1' # целое число превращаю в строку

13 '123'.isdigit() # проверяет состоит ли строка из чисел digit(цифра)
True ## проверяет числовое ли значение поэтому true 

14 '123adf'.isdigit()
False  ## строка содержит и буквы и цифры

15  '123'.isalpha() ## состоит ли из букв строка alpha alphabet
False

16 'hello'.isalpha()
True
================================================

Урок 5 переменные 
dry dont repeat yourself

1 Пример dry
print('leon', 100) ## без отступов!!!!

print('leon', 100)

print('leon', 100)
leon 100 ### вывод 3 раза

2 хороший Пример
rating = 120 ## в оперативной памяти создается объект которому присваивается переменная rating
##создаю переменную чтобы при изменение автоматом менялись значения
print('leon', rating)

print('leon', rating)

print('leon', 100)

rating = 120 ## если снизу то работать не будет надо выше python начинает выше снизу он еще не знает что внизу такая переменная

3 Python как и в Linux регистрозависимый если с большой и маленькой буквы разные
несколько слов __
movie_rating ##как пример

4
rating = 1000 
rating = 120
## вывод 120 будет переназначение переменной называется

5 Переменные это ссылки на объект!!!!!!
1 
a = 1
id(a)
9784864 ## одинаковые будут у них
b = a
id(b)
9784864 ## одинаковые будут у них

 b = 'hello'
 id(b)  
139671715774896 ### уже другое значение ссылка поменялась

2 a = 1
>>> id(a)
9784864
>>> type(a)
<class 'int'>
>>> a = 'hello'
>>> type(a)
<class 'str'> ## уже другой объект
===============================================================================================

Урок 6 строки lvl 2, неизменяемые объекты
1 неизменяемость строк
>>> a = 'hello'
>>> dir(a) ## смотрю методы которые могу использовать
>>> a.upper()
'HELLO' ### сделал с большой
>>> a
'hello' ## все равно само значение не поменялось

2 >>> id(a)
139671715774896
>>> b = a.upper() ### b присваиваю а с методом
>>> id(b)
139671724912112 ## другой id так как другой объект
>>> b
'HELLO' ### вывод
>>> a
'hello'
>>> 

3 изменение значения
>>> a = 'hello'
>>> a = a.upper()
>>> a
'HELLO' ## вот теперь значение точно поменялось

4 
name = 'World'
s = 'Hello {}'
result = s.format(name) ## метод форматирования переменной s в строку подставили переменную name!!!!!!!!!!!
print(result)
Hello World ### вывод значения

### result = s.format(Oleg) если так то будет Hello Oleg!1

5 Пример с рейтингом фильмов

name = 'Leon'

number = 100

pattern = '{} - {}' ### значения куда можно подствлять

result = pattern.format(name, number) #### значение переменных без кавычек
print(result)
Leon - 100
#####
result = pattern.format(number, name) ## вывод будет 100 Leon

6 Можно и так

name = 'Leon'

number = 100

pattern = '{movie} - {rating}' ## присваиваю переменные

result = pattern.format(movie=name, rating=number) ### присваиваю переменные старым значениям без пробелов
### тоже самое если бы  movie='Leon', rating=100
print(result)
Leon - 100 ### тот же вывод

7 новшество python 3.6 fstring

name = 'Leon'

number = 100

result = f'{name} - {number}' ### новшество python 3.6 f строки можно заниматься математикой самый распротраненный способ
 ### тут арифметику все таки не надо так как код плохо читается
print(result)
Leon - 100 ## вывод

================================================
Урок 7 функции

1 это тоже функции
print()
type()
id()

2 функция это именнованный кусок кода что-то делают
тоже самое как переменная, только грубо говоря переменная кода который что-то делает
Двух и более кусков кодов, которые выполняют одинаковые работы

3
movie = 'The good, the bad, and the ugly'
rating = 100

result = f'Movie: {movie}, rating: {rating}'
print(result)
Movie: The good, the bad, and the ugly, rating: 100 ### вывод 
###result = f'Movie: "{movie}", rating: {rating}' ### можно сделать чтобы выводилось в кавычках




4

movie = 'The good, the bad, and the ugly'
rating = 100
result = f'Movie: {movie}, rating: {rating}'


movie = 'Alien'
rating = 200
result = f'Movie: "{movie}", rating: {rating}'
print(result)
## слишком много кода нужна функция!!!

Movie: The good, the bad, and the ugly, rating: 100 ## вывод то что выше и ниже
Movie: "Alien", rating: 200



5
1 def greet():
	print('Hello world') # правило написания функций обязательно tab или 4 отступа shift + tab вернуться обратно

greet() ## обрашение к функциии теперь могу обращаться к функции
Hello world ## вывод

2 def greet(name):  ### параметр функции
	#print('Hello', name) # можно так
	result = f'Hello {name}' ### а лучше так!!!
	print(result)

greet('world')### аргумент передаю значение переменной name
greet('Oleg') ### аргумент называется
greet() ## будет ошибка нету аргумента name
Hello world #### вывод функции
Hello Oleg


3 Рабута функции с двумя параметрами
def greet(message, name): # параметр message добавил
	result = f'{message}, {name}' 
	print(result)
	
greet('Hello', 'world') ### Hello присвоется переменной message, world присвоется переменной name, т.е. позиционность имеет значение
Hello, world ## вывод

greet(message='Hello', name='world') ### можно так
greet(name='world', message='Hello') ###  так, как message name в функции заданы в такой последовательности поэтому Hello, world
Hello, world ## однако вывод и первого и последнего будет такой же в втором случае главное позиционность 

### Ошибки которые могут возникнуть
greet('Hello', 'world', 'adf')  ### будет ошибка три аргумента
greet('Hello') ### тут будет ошибка один аргумент


#Исключения ошибок
def greet(message, name='world'): #если будет так то ошибки не будет именование переменной
	result = f'{message}, {name}' 
	print(result)

greet(message=Hello) ### ошибки не будет так как у name уже задано значениие
greet('Hello', 'sun') ### можно и так world заменит на sun
Hello, world ## вывод
Hello, sun

3.1
def greet(message, name='world'):
	result = f'{message}, {name}' 
	print(result)
	
greet(name='asdf', 'Hello') ## так будет ошибка
greet('Hello', name='asdf') ### так ошибки не будет так как соблюдена позиционность

3.2
greeting = 'hello'
to = 'world'

def greet(message, name='world'):
	result = f'{message}, {name}' 
	print(result)
	
greet(greeting, to) ### так ошибки не будет так как передаются сами значения переменной в функции а не сами значения переменной
hello, world
### функцию попадают значения по сути здесь произошло следующие
## message = greeting = 'hello'

3.3 
greeting = 'hi' ## если так будет  то вывод будет
to = 'world'


def greet(message, name='world'):
	result = f'{message}, {name}' 
	print(result)
	
greet(greeting, to) ### так ошибки не будет так как передаются сами значения переменной в функции а не сами значения переменной
hi, world

3.4 return

greeting = 'hi'
to = 'world'

def greet(message, name='world'):
	result = f'{message}, {name}' 
	return result ## возврат нужно чтобы передавать результат работы функции с одной в другую
	
g = greet(greeting, to) ### ловлю мячь результат ##
print(g) ## результат одной функции был передан в функцию print
hi, world

3.5 еще один споособ с return

greeting = 'hi'
to = 'world'

def greet(message, name='world'):
	result = f'{message}, {name}' 
	return result ## возврат нужно чтобы передавать результат работы функции с одной в другую

#print(greet('hello'))
#hello, world ### вместо hi будет hello

#g = greet('           hello')
#print(g)
#           hello, world### вывод будет такой с оступами

#g = greet('           hello').title() ### можно использовать метод title
#print(g)
#           Hello, World ### вывод заглавных букв но отступами

#g = greet('           hello').title().strip() ### можно использовать сразу 2 метода title и strip
#print(g)
#Hello, World ### вывод заглавных букв

=======================================
Урок Основы Python #7: пространство имен, область видимости

1 def a()
	print(locals()) ## функция locals возвращает словарь значения переменных
# Словарь это как телефонная книжка записана фамилия и ее значение
a() ## выведит пустой словарь
{} ### вывод


2 
def a(name): ### параметр функции
	print(locals()) ## функция locals возвращает словарь значения переменных
# Словарь это как телефонная книжка записана фамилия и ее значение
a('Hello') # присвоил значение переменной
{'name': 'Hello'} ## вывод словаря

3
name = 'Eroha'
name = 'Pupkin' ### 

print(name)
Pupkin ## вывод


4 
name = 'Eroha'

def a():
	name = 'Pupkin' ### Pupkin находится в пределах самой функции

print(name)
Eroha ### выведит Pupkin находится в пространстве имен самой функции

5 Еще один пример кода выше
name = 'Eroha'

def a():
	name = 'Pupkin' 
	print(locals())
a()
{'name': 'Pupkin'} ## вывод name значение переменной




6 
name = 'Eroha'

def a():
	name = 'Pupkin' 
	age = 12 			### еще одна переменнная
	print(locals())
a()
{'name': 'Pupkin', 'age': 12} ## locals вызывает словарь со с значением переменных


7 
name = 'Eroha'

def a():
	name = 'Pupkin' 
	age = 12
	print('Function a() namespace:', locals()) ### локальное пространство имен


print('External namespace', locals()) ### внешние пространство имен external
print() ## это пробел отступ на один урувень ниже
a()
Вывод 
# внешние пространство имен имеет большое значение перемменных
External namespace {'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x7f844e8f36d0>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>, '__file__': 'functions.py', '__cached__': None, 'name': 'Eroha', 'a': <function a at 0x7f844e88be50>}

Function a() namespace: {'name': 'Pupkin', 'age': 12} ### локальный все те же 2 переменные


8 legb
local ### локальное пространство имен
enclosed ###  выше на ступеньку local но еще не глобальное
global ## глобальное пространство имен уровень нет оступа и нету идентации
built-ins ## встроенные функуии locals dir

Пример 

name = 'Eroha'

def a(): ### сначало python пройдет по этой функции
	name = 'in a()' 
	print(name)

	def b():  ## еще один уровень вложенности
		name = 'Pupkin' 
		print(name) #### потом python пройдет по вложенной функции
		print(locals())
	b()
a() ### вызов функции a
in a() #### вывод
Pupkin
{'name': 'Pupkin'} ### localls словарь переменнных


8.1
name = 'Eroha'

def a():
	name = 'in a()' 

	def b():  ## еще один уровень вложенности
		#name = 'Pupkin' ## закоментил
		print(name) ### python будет искать значение name но он не найдет ее в функции def(b) и поднимется выше и возьмет оттуда значение
		print(locals())
	b()
a() ### вызов функции a
in a() ###вывод python не нашел в функции значение name поэтому возьмет значение выше
{'name': 'in a()'}


8.2 тоже самое только закоментировал 
name = 'Eroha'

def a():
	#name = 'in a()' 

	def b():  ## еще один уровень вложенности
		#name = 'Pupkin' ## закоментил
		print(name) ### python будет искать значение name но он не найдет ее в функции def(b) и поднимется выше и возьмет оттуда значение
		print(locals())
	b()
a() ### вызов функции a
Eroha ## вывод python не найдет значение поэтому поднеметнся еще выше поэтому значение Eroha
{}

# При выполении python поднимается наверх начинается с локального потом идет глобальный уровень, потом встроенные функции built in
Каждый раз создавая функцию мы создаем локальное пространство имен, область видимости

================================================
Урок 9 Основы Python #8: if, else, boolean
Пример переход улицы
магазин по списку надо ли оно нам
авторизация на сайте

1 boolean True False
>>> 2 * 2 == 5 #### == значит равно просто = это присвавивание
 False

10 + 10 < 21
True

2 
if True:
	print('ok')
ok ### выведит

3
if 2 * 2 == 4: ##условие
	print('ok') #### инструкция
ok ### вывод 4 равно 4

4 

if 2 * 2 == 5:
	print('ok')
else:
	print('Not ok') 
Not ok ### вывод так как 4 == 5 будет не равно

5 
Операторы сравнения 
!=
<=
>=
not операция отрицания
not True
False ### вывод

not False
True ### вывод
and # true true и наоборот все части должны вернуть true
or ###  true или false
 
password = '123' 
user_input = '00000' ## базовая проверка ввода пользователя
 
if user_input == password: ##если pass равен user input т.е. 123 то welcome
	print('welcome')
else:
	print('Wrong password')
Wrong password ### вывод 123 не равно 00000

6 
password = '123'
user_input = '00000'

if (user_input == password) and (2 * 2 == 4): # один блок не выполен значит false, значит wrong password
	print('welcome')
else:
	print('Wrong password')
Wrong password ### вывод 

7 Тоже самое только or

password = '123'
user_input = '00000'

if (user_input == password) or (2 * 2 == 4): ### так как один блок кода True 4 == 4 то будет welcome
	print('welcome')
else:
	print('Wrong password')
welcome #вывод

8 
if 'a': ### любое не нулевое значение python интерпретирует как true, даже просто пробел " "
	print('welcome')
else:
	print('Wrong password')
welcome ## вывод

if '': ## пустое значение
	print('welcome')
else:
	print('Wrong password')
Wrong password ### вывод, т.к. пустое значение 

9 if 'a' in 'Pupkin': ## если а есть в Pupkin то true но будет false
	print('welcome')
else:
	print('Wrong password')
Wrong password ## вывод

10 elif (else if)
if  # последовательность
elif
else

s = '12345678'

if len(s) == 8:
	print('Length 8')
elif len(s) == 6:
	print('Length 6')
else:
	print('asff')
Length 8 ## вывод


11

password = '123'
user_input = '00000'

if user_input: ## True есть такая переменная
	if user_input == password:  ### внутренния проверка false не равно 123  == 00000
		print('welcome')
	else:
		print('Wrong password') ### поэтому перешло сюда иначе т.к. false 

else:                    ## что то другое тогда внешние условие
	print('Input smth please')
Wrong password ##  поэтому такой и вывод

12 
1
password = '123'
user_input = '00000'

print('Welcome') if user_input else print('Wrong password') ## неудобная конструкция неудобно читать
Welcome ## вывод есть такая переменнная

2
password = '123'
user_input = ''

print('Welcome') if user_input else print('Wrong password')
Wrong password ## вывод пустое значение 

13.1
s = '' ## интерперетатор
dir(s) ## посмотрел методы
s = '123'
s.isdigit() ## есть ли цифры в строке
True ## вывод

13.2 
s = '123а'
s.isdigit() ## есть ли цифры в строке
false  ## вывод есть буквы


14 Собеседование вопрос
# 1 - 100 от 1 до 100
# 3 - fizz # кратно 3 то будет Fizz кратно 3 значит число делится на 3 без остатка
# 5 - Buzz ## кратно 5 то будет Buzz
# 3 & 5  кратно 3 и 5 будет FizzBuzz
# i # остальные случаи

def fizz_buz(i):
	if (i % 3 == 0) and (i % 5 == 0): ## это условие не будет выполнено никогда если будет внизу последовательность условий важно
	# if not (i % 3) and (i % 5): # тоже самое будет работать остаток от деления либо 0 либо нет 0 это значит false поэтому not (false ) не ноль
		print('FizzBuzz')
	elif i % 3 == 0: ### если число при делении на 3 дает нам остаток 0 т.е. спокойно делится на 3 без остатка
		print('Fizz')
	elif i % 5 == 0: ### если число при делении на 5 дает нам остаток 0 т.е. спокойно делится на 5 без остатка
		print('Buzz')
	else:
		print(i)

fizz_buz(1)
fizz_buz(2)
fizz_buz(3)
fizz_buz(5)
fizz_buz(7)
fizz_buz(10)
fizz_buz(15)
fizz_buz(17)

Вывод:
1
2
Fizz ## среагировало на 3
Buzz ## среагировало на 5
7
Buzz ## среагировало на 10 можно поделить на 5 
FizzBuzz ## среагировало и на 3 и на 15 и так и так делится
17
========================
Урок 10 Основы Python #9: списки

1 список это массив обратиться к объекту можно по номеру 
1.1>>> [1,2,3,4] ## можно и так
[1, 2, 3, 4]

1.2>>> [1, 2, 'a', 3]
[1, 2, 'a', 3]

1.3 
>>> l = ['a', 'b', 'c', 'd'] ### создание переменной это может быть список постов коментариев
>>> l ## вызов переменнной
['a', 'b', 'c', 'd']


1.4 Обращение к элементу
>>> l[0] ## квадратные скобки
'a'

1.5 Создание дополнительной переменной 
>>> first = l[0]
>>> first
'a'

1.6 l[12] #будет ошибка исключение так такого элемента с индексом нету в списке
l = ['a', 'b', 'c', 'd']
len(l)
4 ## длина списка

1.7 Индекс последнего элемента на единицу будет меньше так как расчет начинается с нуля
>>> len(l) - 1 ### узнаю номер индекса последнего элемента
3
>>> l[len(l) - 1] ## узнаю сам уже последний элемент данного списка в скобках 
#узнаю номер последнего списка -1 так все элементы начинаются с нуля поэтому  -1 
'd' ## l[3] это d  0(a) 1(b) 2(c) 3(d)

4 l[-1] ### синтаксический сахар вызов последнего элемента списка запись выше не очень
d 

5
>>> l[-2]
'c' ### предпоследний элемент

6
l = ['a', 'b', 'c', 'd']
l[1:3] ##  выведит два элемента 1 2, 3 элемент это условное знач вывод до 3, поэтому выводить не будет
['b', 'c'] ## вывод 1(b) 2(c) :3 последние не выводится поэтому только два элемента

7
>>> l[1:] ## выведит от первого до последнего включительно
['b', 'c', 'd'] ## без а так как а нулевой индекс

8 
>>> l[:-1]
['a', 'b', 'c'] ### вывод без последнего элемента

>>> l[:3] # вывод первых 3 элементов по индексу 0 1 2 до 3 уже не вызовет так как до него :3
['a', 'b', 'c'] 

9
l = ['a', 'b', 'c', 'd']
>>> l[: -1:2] ## 2 шаг перерыгивать будет через 1
['a', 'c']

10 Функции списка
dir(l)
Основные методы
вызов . после переменной 
append ### добавляет в конце списка новый элемент
extend
clear
sort ### метод не возвращает новй объект создаются новые объекты
sorted() ## функция тут создаются как понял но не точно
split ## созддает из строки список
s.join(l)

10.1 Пример append
>>> l.append("e") ## круглые скобки и кавычки можно ""  ''
>>> l
['a', 'b', 'c', 'd', 'e']

10.2 Пример extend
>>> l2 = [1, 2, 3, 4] ## создал новый список 
>>> l2 ## вызвал его
[1, 2, 3, 4]
>>> l ## проверил его
['a', 'b', 'c', 'd', 'e']
>>> rl = [] ### создал пустой список
>>> rl.append(l) ### добавил в него список l
>>> rl ## вызов результат ниже
[['a', 'b', 'c', 'd', 'e']]

>>> rl.append(l2) ## добавил в rl список l2
>>> rl ## вызов результат ниже
[['a', 'b', 'c', 'd', 'e'], [1, 2, 3, 4]] ## двойные скобки

>>> rl[0] ## вызов элемента по индексу
['a', 'b', 'c', 'd', 'e'] 
>>> rl[1] ### вызов элемент по индексу 1 будет второй список l2
[1, 2, 3, 4]
>>> 

rl.clear() ## очистка списка
>>> rl
[] 

>>> rl.extend(l) ## добавил список l1
>>> rl
['a', 'b', 'c', 'd', 'e']
>>> rl.extend(l2) ## добавил список l2
>>> rl
['a', 'b', 'c', 'd', 'e', 1, 2, 3, 4] ### в результате получился плоский список где все элементы в одном списке

>>> rl + ['x', 'y', 'z'] ## добавляю x y z редкий способ
['a', 'b', 'c', 'd', 'e', 1, 2, 3, 4, 'x', 'y', 'z'] ## вывод с x y z
>>> rl
['a', 'b', 'c', 'd', 'e', 1, 2, 3, 4] ## но сам список rl останется неизменным 

11 списки изменяемые в отличии от строк

>>> x = 3 ## создал переменную
>>> y = x ### присвоил y 
>>> y
3  
>>> id(x)
9784928 ### теперь у них одинаковое значение
>>> id(y)
9784928
>>> 

>>> x = x + 1
>>> x
4            
>>> id(x)
9784960 ### уже новый объект новый id
>>> y ## но y y останется первоначальное значение
3
Тоже самое будет со стороками

11.1 Пример со списком
>>> l = [] ### создал список пустой
>>> new = l ### присвоил значение переменной new
>>> id(new)
139914995913728 ### один и тот же id у них
>>> id(l)
139914995913728

>>> new.append('a') ### добавил в список a
>>> new ### теперь значение в new и в l тоже поменяется на a ниже вывод, в отличии от цифр и строк
['a']
>>> l
['a']

>>> id(new)
139914995913728 ### объект не поменялся в обоих случаях важное свойство!!!!!!
>>> id(l)
139914995913728

11.2

>>> l
['a']
>>> l.append('b') ### добавляю новый объекты
>>> l.append('m')
>>> l.append('c')
>>> l
['a', 'b', 'm', 'c'] ## вывод

>>> sl = sorted(l) ### переменной sl передам значение функции sorted(l)
>>> sl
['a', 'b', 'c', 'm'] ### вывод будет в алфавитном порядке

>>> l ### останется такой же
['a', 'b', 'm', 'c']

l.sort() ### сортировка в алфавитном порядке
l ## вызов
['a', 'b', 'c', 'm'] ## вывод данного метода будет такой же как в функции sorted(l)

11.3
>>> s = 'Знайка шел гулять на речку\nперепрыгнул через овечку' #### \n для отступа при вызове функции print(s)
>>> s
'Знайка шел гулять на речку\nперепрыгнул через овечку'
>>> print(s)
Знайка шел гулять на речку ## тут будет с отступом
перепрыгнул через овечку

dir(s) ## смотрю методы ищу split
>>> s2 = s.split() ###  переменной s2 присваиваю значение s с методом split который делает список
>>> print(s2)
['Знайка', 'шел', 'гулять', 'на', 'речку', 'перепрыгнул', 'через', 'овечку'] ### split создал список делит по табулятором
### список слов

l = s.split('\n') ### тогда будет вот так
>>> l
['Знайка шел гулять на речку', 'перепрыгнул через овечку'] ## вывод 2 элемента каждая строчка деление по \n


11.4 
s = ''
s
''
s.join(l)
'Знайка шел гулять на речкуперепрыгнул через овечку' ##просто склеил два элемента в один

11.5
>>> s = ' '
>>> s.join(l)
'Знайка шел гулять на речку перепрыгнул через овечку' ## поставит пробел на границе склеивания элементов речкуперепрыгнул склеинные
###  чтобы не было выше
 11.6
 ','.join(l) #####
'Знайка шел гулять на речку, перепрыгнул через овечку' ### поставит запятую на границе склеивания элементов


11.7 пример
children = ['arbuzov_2000', 'ivanov_2011', 'petrov_2010', 'Bubnov_2015'] ### Bub с большой буквы

s_children = sorted(children)
print(s_children)

['Bubnov_2015', 'arbuzov_2000', 'ivanov_2011', 'petrov_2010'] ### вывод  Bubnov с большой поэтому первым остальные по алфавиту
### регистр имеет значение поэтому перед сортировкой необходим приводить к нижнему регистру

Сотировка по году рождения

1 children = ['arbuzov_2000', 'ivanov_2011', 'petrov_2010', 'Bubnov_2015'] ### Bub с большой буквы

def by_year(name):
	splited_name = name.split('_')
	print(splited_name)

by_year(children[0]) ### вызов функции по имени вставляем переменную children c элементом  0 (первый)
['arbuzov', '2000'] ## вывод вместо arbuzov_2000 разделило по _


2 пример сортировка по цифрам
children = ['arbuzov_2000', 'ivanov_2011', 'petrov_2010', 'Bubnov_2015'] ### Bub с большой буквы

def by_year(name):
	return name.split('_')[-1] ## обращений к последнему к первому элементу значение 2000 вывести
	

print(by_year(children[0])) ### так как функция ничего не печатает поэтому надо print указать
2000 ### вывод 

3 пример сортировка по годам
children = ['arbuzov_2000', 'ivanov_2011', 'petrov_2010', 'Bubnov_2015'] ### Bub с большой буквы

def by_year(name):
	return name.split('_')[-1] ## обращений к последнему к первому элементу значение 2000 вывести

s_children = sorted(children, key=by_year) ### key обращение к значению функции by_year поэтому скобки не нужны
### два значения сортировка по цифрам по годам на увеличение
print(s_children)
['arbuzov_2000', 'petrov_2010', 'ivanov_2011', 'Bubnov_2015'] ### вывод по датам начиная от 2000 до 2015


4 Пример 
>>> l = [1, 2, 3, 'a']
sorted(l)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: '<' not supported between instances of 'str' and 'int' ## не может сравнивать строки с цифрами('str' and 'int')
=======================================

Урок 11
Основы Python #10: цикл for, итерируемые объекты


1 Действия которые ввыполняются несколько раз, циклы нужно использовать постоянно
2 цикла:
for
while

Пример
children = ['arbuzov_2000', 'ivanov_2011', 'petrov_2010', 'Bubnov_2015'] ### Bub с большой буквы

for child in children: ## для каждого ребенка(child любое значени ) в списке дети делаем следующие
# берется первый элемент присваивается переменной child тело цикла говорит вывести на экрани оно выводит и так далее
# как только python пройдет он идет в основной цикл
	print(child) 
arbuzov_2000 ### вывод пройдемся по всем значениям
ivanov_2011
petrov_2010
Bubnov_2015

2 
children = ['arbuzov_2000', 'ivanov_2011', 'petrov_2010', 'Bubnov_2015'] ### Bub с большой буквы

names = []

for child_name in children: 
	# arbuzov_2000 > arbuzov, 2000 ## то что делает
	name_parts = child_name.split('_') ##присвоил новое значение переменной, делю по нижнему подчеркиванию разделение 
	print(name_parts)
['arbuzov', '2000'] # вывод
['ivanov', '2011']
['petrov', '2010']
['Bubnov', '2015']

3 Если надо обращаться к имени чисто то 
children = ['arbuzov_2000', 'ivanov_2011', 'petrov_2010', 'Bubnov_2015'] ### Bub с большой буквы

names = []

for child_name in children: 
	# arbuzov_2000 > arbuzov, 2000 ## то что делает
	name_parts = child_name.split('_')[0] ##присвоил новое значение переменной, делю по нижнему подчеркиванию разделение 
	#name_parts = child_name.split('_')[0].title() ### делаю все фамилии заглавными!!!!!
	# [0] обращаюсь к первому элементу списка
	# surname = surname.title() а можно ниже просто написать и тоже делаю чтобы все фамилии были заглавной Arbuzov
	
	print(name_parts)
arbuzov ## вывод после разделения ('_')и создания двух элементов, обращение к первому элементу [0]
ivanov
petrov
Bubnov

4 Новый список создаю names
children = ['arbuzov_2000', 'ivanov_2011', 'petrov_2010', 'Bubnov_2015'] ### Bub с большой буквы

names = []

for child_name in children: 
	# arbuzov_2000 > arbuzov, 2000 ## то что делает
	surname = child_name.split('_')[0].title() ##присвоил новое значение переменной, делю по нижнему подчеркиванию разделение 
	
	names.append(surname) ### новый отфилитрованный список добавляю в переменную names	
print(names)
['Arbuzov', 'Ivanov', 'Petrov', 'Bubnov'] # вывод новый список names

5 итеруемые объекты
>>> s = 'hello'
>>> s
'hello'
>>> dir(s) # тут ищу метод __iter__
>>> i = s.__iter__() ## присвоил значение i потом делаю метод __iter__ для переменной s
>>> i
<str_iterator object at 0x7f4f337eb9a0> ### итератор
dir(i) ## это уже итератор и тут другие методы next к примеру
>>> next(i) ## будет последовательно вызывать элементы
'h'
>>> next(i)
'e'

Цикл for автоматизирует все что здесь было сделано выше

6 Прерывание цикла break
# break тогда после этой команды python резко перейдет в основной код

children = ['arbuzov_2000', 'ivanov_2011', 'petrov_2010', 'Bubnov_2015'] ### Bub с большой буквы

names = []

for child_name in children: 
	surname = child_name.split('_')[0].title() ##присвоил новое значение переменной, делю по нижнему подчеркиванию разделение 
	print(surname)
	break ## Прерываю цикл на первом элементе итерацию


	names.append(surname) ### новый отфилитрованный список добавляю в переменную names	
print(names)
Arbuzov### вывод
[]

7 continue
children = ['arbuzov_2000', 'ivanov_2011', 'petrov_2010', 'Bubnov_2015'] ### Bub с большой буквы

names = []

for child_name in children: #python идет по очереди
	surname = child_name.split('_')[0] ##title убрал a ниже с заглавной, разделили на два элемента убрали _
	#[0] обратились к первому из двух новых элементов
	
	if surname.startswith('a'): ## если фамилия  начинается с а
		continue ## текущая итерация прекратилась так как arbuzov a имеет и цикл пошел далее по новому 
# интерпретатор дошел до continue и прервал итерацию и пошел по новому по списку продолжил работу

	surname = surname.title() ## то что выплюнет цикл выше идет сюда и делает с большой буквы
	names.append(surname) ### новый отфилитрованный список добавляет в переменную names	
print(names)

['Ivanov', 'Petrov', 'Bubnov'] ###арбузова нету так как а есть в этом слове


==================================
Урок 12 Основы Python #11: словари, тип None, функции lvl 2
Словарь отличие от списка обращение в списке по индексу в словаре обращение по ключу
Телефонная книшка это словарь имя человека по нему находим номер телефона тоже самое и Словарь
1 {} ## помни словарь такие скобки после : пробел после каждого значения запятая

2 d = dict(name='petr', tel='1234') ## можно и так создавать словари через функцию (dict)
name = person['name'] ### обращение к ключу словря person 

3 new = {'name': 'dima'}
person.update(new) ## поменял значение ключа name на новое значение dima
person.update(name='dimas', tel='1234') # второй способ добавление ключа и переменной вывод такой же



1 пример
person = {'name': 'vasja', 'surname': 'pupkin', 'email': 'test@gmail.com'}
print(person) 

{'name': 'vasja', 'surname': 'pupkin', 'email': 'test@gmail.com'} ### вывод 


d = dict(name='petr', tel='1234') ## можно и так создавать словари через функцию (dict)
print(d)
{'name': 'petr', 'tel': '1234'} ## вывод



2.1 Обращение к словарю

person = {'name': 'vasja', 'surname': 'pupkin', 'email': 'test@gmail.com'}

d = dict(name='petr', tel='1234') ## можно и так создавать словари через функцию (dict)

name = person['name'] ### создал переменную name присвоиле ей значение словаря конкретный ключ и вывел на экран
print(name) 
#print(name) если обращусь по ключу которого нету будет keyerror
vasja ## вывод  обратился ключу name и значение присвоил переменной name и вывел через функцию


2.2 
person = {'name': 'vasja', 'surname': 'pupkin', 'email': 'test@gmail.com'}

d = dict(name='petr', tel='1234')

tel = person.get('tel')
print(tel)
None ### но уже ошибки не будет

tel = person.get('tel', '1234123') ## если ничего не будет выведит значение по умолчанию
print(tel)
12341234

tel = d.get('tel', '1234123')
1234 ###выведит так как есть клюючь tel а так бы вывело 12341234

2.3 setdefault добавляем ключ если его нету

person = {'name': 'vasja', 'surname': 'pupkin', 'email': 'test@gmail.com'}

d = dict(name='petr', tel='1234')


tel = person.setdefault('tel', '12341234') 
print(tel)
print() ## отступ 1
print(person)
12341234 ## вывод person.setdefault зашел посмотрел что нету tel ключа создал его присвоил значение 12341234, потом присвоил значение переменной
# print(tel) и вывел 12341234
							# отступ
{'name': 'vasja', 'surname': 'pupkin', 'email': 'test@gmail.com', 'tel': '12341234'} ### person.setdefault так как добавил новый ключь он там и появился

2.4 циклы в словарях

person = {'name': 'vasja', 'surname': 'pupkin', 'email': 'test@gmail.com'}

d = dict(name='petr', tel='1234') # в этом примере ничего не делает

for item in person:
	print(item)

name ## вывод обратиться по ключам к словарю person
surname
email

2.5 Метод ключей
person = {'name': 'vasja', 'surname': 'pupkin', 'email': 'test@gmail.com'}

d = dict(name='petr', tel='1234') #в этом примере ничего не делает

for item in person.keys(): ## метод keys тоже самое что выше
# for item in person.items(): #выедит все ключи и значения типо того  ('name', 'vasja') кортежи списки которые менять нельзя
	print(item)
name ### вывод по ключам
surname
email

2.6 распкаовка списков, кортежей 
Пример для списков распаковки
a, b = [1, 2] ## две переменные значения в списке
print(a) # распаковка списка
print(b)
1 ## вывод 
2

2.7 Распокавка словаря
person = {'name': 'vasja', 'surname': 'pupkin', 'email': 'test@gmail.com'}

d = dict(name='petr', tel='1234')

for key, value in person.items(): ## можно пробежаться по ключу(key) и значению (value)
	print(key, value)
name vasja ## вывод ключ и значение
surname pupkin
email test@gmail.com

2.8 обновление значений
person = {'name': 'vasja', 'surname': 'pupkin', 'email': 'test@gmail.com'}

d = dict(name='petr', tel='1234')

new = {'name': 'dima'}
person.update(new) ## поменял значение ключа name на новое значение dima
print(person)
{'name': 'dima', 'surname': 'pupkin', 'email': 'test@gmail.com'} ## name имеет значеие dima

2.9 Добавление нового ключа
person = {'name': 'vasja', 'surname': 'pupkin', 'email': 'test@gmail.com'}

d = dict(name='petr', tel='1234')

new = {'name': 'dima', 'tel': '8029'} ## добавление нового ключа
person.update(new) ## поменял значение ключа name на новое значение dima, также добавил новый ключ и значение
#person.update(name='dimas', tel='1234') # второй способ добавление ключа и переменной вывод такой же
# {'name': 'dimas', 'surname': 'pupkin', 'email': 'test@gmail.com', 'tel': '8029' 

print(person)
{'name': 'dima', 'surname': 'pupkin', 'email': 'test@gmail.com', 'tel': '123'}


3.0 None
def a():
	print('hello world')
	#	return None # лучше наверное так но вывод будет такой же
	# 	return 
	
result = a()
print(result)# это глобальная переменная
hello world ## вывод result функция сработает, но дальше будет none функция только возращает значение
None  ## неявное поэтому и выведит
=========================================

Урок 13 Основы Python #12: цикл While
пролистать книгу с первой страницы до последней это цикл for 
копать это цикл while (пока)

1 бесконечный цикл
counter = 0 ## создал переменную
while True: ### пока true то выполняем следующие это бесконечный цикл
	print(counter)        ### тело цикла указываем инструкции
	counter += 1 ## добавляем 1 и по новому, counter = counter + 1 эти записи индентичны
26947 ### бесконечный цикл начиная от 1
26948
26949
26950
26951

2 Конечный цикл
counter = 0 ## создал переменную
while counter < 20: ### создаю конечный цикл пока меньше 20
	print(counter)        ### тело цикла указываем инструкции
	counter += 1 ## добавляем 1 и по новому, counter = counter + 1 эти записи индентичны
0 ## вывод от 0 до 19 меньше 20
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19

3 Цикл используется когда знаем сколько раз он будет выполняться игры, чаты 

counter = 0 ## создал переменную
while True: ### опять создаю бесконечный цикл
	print(counter)        ### тело цикла указываем инструкции
	if counter >= 20: ### однако создаю такое условие
		break 		### остановить если более 20 или равно вывод будет тот же
	counter += 1 ## добавляем 1 и по новому, counter = counter + 1 эти записи индентичны
Вывод будет тот же что и выше

====================================

Урок 14 Основы Python #13: Работа с файлами, with
файлы именнованные области которыми управляется операционная система
со стороны python это тип данных

1 open("readme.txt")
2 open('readme.txt', mode = 'r') # режим mode r read чтение так редки чаще ниже
3 open('readme.txt', 'r') ## так можно так как режим mode по умолчанию второй идет по счету
4 file = open('readme.txt', 'w') ## w write запись python будет искать данный файл если не найдет то создаст
## реально создаст файл в текущей директории
>>> file
<_io.TextIOWrapper name='readme.txt' mode='w' encoding='UTF-8'>
type(file)
<class '_io.TextIOWrapper'> # тип IO input output вывод и принимает Wrapperr обвертка текстового файлу
виды ввода вывод (IO)
Text IO
Binary IO # буферизованные типы данны все что не текст file = open('readme', 'wb') # для бинарных запись так а чтение через rb 
Raw IO # не буфиризованный тип данных

5
file = open('readme.txt', 'w')
dir(file) ## смотрю методы
file.write('1') ## ничего не будет вводим только текст поэтому кавычки и это текстовый файл
### ничего не будет так как файл находится в буфере
1 ## вывод 
file.close() ## ввожу после чего в файле появиться 1 файлы желательно всегда закрывать иначе могут быть утечки памяти
file.flush() ## метода который выталкивает с оперативной памяти на диск файл когда он открыт

6 
file = open('readme.txt', 'w')
file.write('1') ##будет постоянно единица
file.close() ### закрываем чтобы вытолкнуть инфу с оперативной памяти на жесткий диск

file = open('readme.txt', 'a') ## a append добавить в конце строки новый элемент каждый вызов будет в конце добавлять доп цифру
 #12 #будет постоянно добавлять в конец
file.write('2')
file.close()

7 чтение файлов
file = open('readme.txt')

data = file.read() ## функция read которая позволяет читать файлы, читает циликом
# создал переменную data и присвоил значение file при методе read
print(data)
file.close()
12 #
## есть еще важный метод .readlines()

8 бинарные файлы
pic = 'go.jpg' # картинка это не текстовый файл  это бинарный файл
file = open(pic)

new_file = open('copy_' + pic, 'w')
new_file.write(file.read()) # метод write только для текста а не для байтов
# будет ошибка что картинка это не текст и нельзя открывать картинку как текст

НО если я сделаю так:

pic = 'go.jpg' # картинка это не текстовый файл  это бинарный файл
file = open(pic, 'rb') # rb прочитать как бинарный файл

new_file = open('copy_' + pic, 'wb') ## тогда ошибки здесь не будет
new_file.write(file.read()) ### все сработает тогда

9 с версии 3.0 автоматически можно закрыть файлы with as
>>> with open('readme.txt', 'w') as file: ## with c сохранить as как file 
...     file.write('hello world')
... 
11 ## покажет что файл уже весит 11 байт если файл открыть там будет запись hello world
>>> 
=========================================
Урок 15  Основы Python #14: уровни абстракции (мини quasi лаба)
1 
# 1000 : 15 = mass : x ### 1000 мука 15 соль
# mass : x ## можно и так записать
# x = 15 * mass / 1000 ## проверил так и есть ищем сколько грамм надо при произвольной массе

def get_salt_mass(m): ##функция масса такая -то 
	return m * 15 / 1000 ### верни нам расчет сколько надо соли при такой то массе
print(get_salt_mass(1500)) # распечатай нам сколько соли надо когда мука весит 1500
22.5 ### получается что нужно 22.5 грамм соли

2
def get_salt_mass(m): ##функция масса такая -то 
	return m * 15 / 1000 ### верни нам расчет сколько надо соли при такой то массе

def get_pepper_mass(m): ## масса перца нарушения метода DRY!!!код повторяется
	return m * 5 /1000 ## по сути таже функция 

print(get_salt_mass(1500)) # распечатай нам сколько соли надо когда мука весит 1500
22.5 ### получается что нужно 22.5 грамм соли

3 Решение проблемы метода DRY
ingredients = {
	'salt': 15,
	'pepper': 5
}

def get_salt_mass(m): ##функция масса такая -то 
	return m * 15 / 1000 ### верни нам расчет сколько надо соли при такой то массе

def get_pepper_mass(m): ## масса перца нарушения метода DRY!!!код повторяется
	return m * 5 /1000 ## по сути таже функция 

def get_ingredient_mass(m, ingr): ## m  масса ingr это ключь ингридеинта два параметра словаря ключ и значение "salt": 15
 	return m * ingredients[ingr] / 1000
	# return m * ingredients.get(ingr, 0) / 1000 будет возращать 0 если туда положить корицу чего нету

print(get_ingredient_mass(1500, 'salt'))
22.5 # это вывод сколько надо соли на 1500 грамм мяса муки и так далее

4 Оборачивание чужих функций в наши
#\n  new line переводится
help(print) # смотрю что может print

def print_wrapper(text):
    with open('readme', 'w') as f: # создаю объект файл readme сохранияю его в переменную f он реально появиться в папке
    # with open('readme', 'a') as f: ### и там будет возникать новые числа с новой строки когда используешь print_wrapper(2)   
        print(text, file=f)


print_wrapper(1) ## появиться новый файл и там возникнет 1 


==========================================================

Урок 16 Основы Python #15: Исключения
Исключения это события которого возникает во время ошибки
Исключения прерывает работу скрипта 

1
def main(): ## функция
    data = {"website": "google"} # словарь
    print(data['url']) ### обращение к несуществующему ключу будет ошибка исключения далее код больше уже выполняться не будет
	summ = 1 + 1  ## этот валидный код далее уже не будет выполняться
	print(summ)

main() ## вызов функции main будет ошибка так как нету такого ключа

2 Делаем правильно try except  
def main():
    data = {"website": "google"}
    try: # попробую
        print(data['url']) ## ключа нету такого возбуждено исключение python видит try и отменяет все действия
    except: # потом python передает управление в блог except
        summ = 1 + 1  ## этот валидный код и он выполниться
        print(summ)

main()
2 #вывод 2 выведит так как валидный код

3 еще один пример с keyerror исключением
Методы
get
setdefault

def main():
    d = {"website": "google"}
    try: 
        data = d['url'] ## ключа нету такого возбуждено исключение python видит try и отменяет все действия
    except: # потом python передает управление в блог except
        data = 'https://'  ## этот валидный код и он выполниться
        print(data)

main()
https:// ## вывод опять сверху сработает исключение все отмениться там где try, и перейдет в except:

4 NameError обращение к переменной которой нету 

def main():
    d = {"website": "google"}
    try: 
		print(asdf) ## будет ошибка так как это уже исключение NameError нету такой переменной
	    data = d['url'] ## ключа нету такого возбуждено исключение python видит try и отменяет все действия
    except KeyError : # потом python передает управление в блог except, KeyError(ошибка когда обращение к ключу словаря которого нету)  исключения конкретной ошибки 
        ## тогда код выполниться если всплывет данное исключение  но здесь не поможет так как у нас еще NameError
		data = 'https://'  ## этот валидный код и он выполниться
        print(data)

main()

5 Доп except
5.1

def main():
    d = {"website": "google"}
    try: 
		print(asdf) ## будет ошибка так как это уже исключение NameError нету такой переменной
	    data = d['url'] ## ключа нету такого возбуждено исключение python видит try и отменяет все действия
    except : # потом python передает управление в блог except
        data = 'https://'  ## этот валидный код и он выполниться
        
	except:      ## делаю если есть не придведенная ошибка то выведит на печать ooops
	# но если я попытаюсь руками остановить (keyboardinterrupt) все равно будет данная ошибка поэтому except Exception:
		print('ooops')
main()
ooops ## выведит данную ошибку
Аккуратней с пробелами


6 Finally

def main():
    d = {"website": "google"}
    try:
        print(asdf) 
        data = d['url'] ## ключа нету такого возбуждено исключение python видит try и отменяет все действия

    except: # потом python передает управление в блог except
        data = 'https://'  ## этот валидный код и он выполниться
        print('Inside except', data)
        return data

    finally:
        print('very important action')
result = main() ## перехватываю return
print(result)

Inside except https:// # 1 except python пройдет сверху вниз сначало выполнит до return, потом finally, потом вернется в except в return
very important action #2 finally
https:// ## возврат в except выполнение return

Последовательность
try
except
else ## если надо
finally 

7 else
1
def main():
    d = {"website": "google"}
    try:
        data = d['url'] 
    except: 
        data = 'https://'  
        
    else:
        data = data.upper()
    print(data)
        
main() 
https:// ## вывод результата

2 
def main():
    d = {"website": "google", 'url': 'google.ru'} ## новый ключ url
    try:
        data = d['url'] 
    except: 
        data = 'https://'  
        
    else:
        data = data.upper()
    print(data)
        
main() 
GOOGLE.RU ## вывод с большой буквы  data.upper()
в try надо вставлять то что мы знаем что можно что-то ввести и возникнет исключение(ошибка), надо всталять одну строку
и except побольше по возможности
else очень полезен особенно когда ничего не происходит 
=============================================
Урок 17 Основы Python #16: импорт модулей

Операция import дает нам доступ к глобальной области видимости импортируемога файла config и его переменных

1 config.py
token = 'dadsadasdsad'

main.py
print(locals()) ## результат будет словарь 

{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x7f16b6591760>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>, '__file__': 'main.py', '__cached__': None}
#вывод однако переменной token тут нету, поэтому обратиться к ней мы не можем так как ее нету в данной области видимости

2 импорт модулей
import config # без формата .py
print(locals()) ## результат будет словарь 
'config': <module 'config' from '/home/sam/desktop/Python_basics/config.py'>}
## вывод появиться инфа о нашем файле который мы создавали в начале
print(dir(config)) ## уже появиться информация о переменной token 
'token']

3 Узнаю значение о переменной token

import config
print(locals()) ## результат будет словарь 

print(config.token) ## узнаю значение о переменной token !!!!
dadsadasdsad ### вывод 

Операция import дает нам доступ к глобальной области видимости импортируемога файла config и его переменных



4 from
Импортирую конкретную переменную token из области видимости config в область видимости main.py
1 
from config import token
print(locals()) ## результат будет словарь 


{.... 'token': 'dadsadasdsad'} ## вывод увидим конкретную переменную 

2 изменение переменной 
from config import token ### такой метод импорта не очень!!!!
token = 'hello world' ## меняю значение переменной
print(locals()) ## результат будет словарь 

{.... 'token': 'hello world'} # переменная поменялась

3 from config import * ### такой способ дучше импортирую все переменные, но тоже не лучшая практика только если надо


5 all
config.py

__all__ = [ ### указываю что и можно импортировать из данного файла через * в другой файл
    'email', # указываю значение переменной  
    #[..] ## если надо еще что-то добавить то так через запятую
]

email = 'google@google.ru'
token = 'dadsadasdsad'


main.py
from config import *
print(locals()) ## результат будет словарь 
 'email': 'google@google.ru'} # появиться вот такая запись
 Импортирование означает не только импортировать код но и его выполнить. При первом импорте происходит выполнения кода целиком.

6 Пример выполения кода при импорте
config.py

print('From config with love')

from time import sleep ## из модуля time импортирую функциию sleep

sleep(10)
email = 'google@google.ru'
token = 'dadsadasdsad'

main.py

print(locals()) ## сначало распечатается данный словарь про token там не слова
print() ## пустая строка отступ потом это

from config import token

print(locals()) ### опять
Вывод
{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x7f380d7b8760>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>, '__file__': 'main.py', '__cached__': None}
# и print(locals()) и пустая строка
From config with love ######выполниться данная запись с файла config.py то что выше смотри
## ипортировал функцию sleep, потом по спит выполнит функцию sleep 10 сек
# создал объекты email, token, но импортировал только token 
{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x7f380d7b8760>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>, '__file__': 'main.py', '__cached__': None, 'token': 'dadsadasdsad'}


7 '__name__': '__main__' # про них
config.py

print('__name__ variable of the config.py module \n', __name__)

from time import sleep ## из модуля time импортирую функциию sleep

sleep(10)
email = 'google@google.ru'
token = 'dadsadasdsad'

def main():
    pass

if __name__ == '__main__': # если name равно main то вызываем функцию main()
    main() ### условие и сравнение
## если данный файл запуститься как главный то сработает функция __main__
__name__ variable of the config.py module 
__main__ ## отдало main  так как это главный файл при вызове его


main.py
print(locals()) ## результат будет словарь 
print() ## пустая строка отступ

from config import token

print(locals()) ### опять
# условие main из импортируемого файла config.py 
# не выполниться так как он уже не главный файл